<!DOCTYPE HTML>
<html>
  <head>
	<!-- Name: Daelyn Doughty -->
	<!-- Assignment: 4 -->
	<!-- Due date: 3/27/2024 -->
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <script type="text/javascript" charset="utf-8" src="./renderer.js"></script>
    <script type="text/javascript" charset="utf-8" src="lib/controls.js"></script>
    <script type="text/javascript" charset="utf-8" src="lib/gl-matrix-min.js"></script>
    <style type="text/css">
      body {text-align: center;}
      table {margin:0 auto;}
      table td, th {text-align: left;padding:2px 10px;}
      table th {text-align: right;}
      canvas {border: 2px solid black;}
      input {width:160px;}
      div{float: right;}
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div>
    	<h3>Controls</h3>
    	<table>
    		<tr>
    			<th>Left Mouse:</th><td>Pan</td>
    		</tr><tr>
    			<th>Right Mouse:</th><td>Rotate</td>
    		</tr><tr>
    			<th>Spacebar:</th><td>Reset Cam Position</td>
    		</tr><tr>
    			<th>Resolution:</th><td><button onclick="renderer.updateSize(600,600);">600x600</button>&nbsp<button onclick="renderer.updateSize(600,1200);">1200x600</button></td>
    		</tr><tr>
    			<th>Focal Length:</th><td><input id="iFocalLength" type="number" oninput="renderer.update();"/></td>
    		</tr><tr>
    			<th>Epsilon:</th><td><input id="iEpsilon" type="number" oninput="renderer.update();"/></td>
    		</tr><tr>
    			<th colspan="2"><button onclick="renderer.resetCameraParameters();">Reset Cam Parameters</button></th>
			</tr>
    	</table>
	</div>

	<script id="vertexShader" type="x-shader/x-vertex">
		attribute vec2 aVertexPosition;
		varying vec2 vPixelCoord;

		void main(void) {
			gl_Position = vec4(aVertexPosition, 0, 1);
		}
	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		precision mediump float;

		const float INFINITY = 1e9;
		const int   MAX_MARCHING_STEPS = 400;

		// -------------------------------------------------------------------------

		// Camera uniforms
		struct Camera
		{
			vec3 up;			// Up-vector
			vec3 right;			// Right-vector
			vec3 forward;		// Forward-vector
			vec3 eye;			// Eye position
			float aspectRatio;	// Ratio between screen width and height
			float focalLength;	// Distance between the eye and the image plane
		};

		uniform Camera uCamera;

		// -------------------------------------------------------------------------

		struct Light {
			vec3 position;
			vec3 color;
			float ambientIntensity; // Daelyn: added parameters for phong shading
			float diffuseIntensity;
			float specularIntensity;
		};
		

		uniform Light uLights[2];

		// Daelyn: defining material properties
		struct Material {
			vec3 ambientColor;
			vec3 diffuseColor;
			vec3 specularColor;
			float shininess;
		};
		
		// -------------------------------------------------------------------------

		struct Settings
		{
			int numberSteps;	// Max number of raymarch steps
			float epsilon;		// Surface threshold
			vec2 resolution;	// Resolution of the view port
		};

		uniform Settings uSettings;

		// -------------------------------------------------------------------------

		// DISTANCE FUNCTIONS FOR OBJECTS

		// plane
		float dPlane( vec3 x )
		{
			return x.y;
		}
		
		// sphere
		float dSphere( vec3 x, vec3 c, float r )
		{
			return length( x-c ) - r;
		}
		
		// Daelyn: cube
		float dCube(vec3 p, vec3 c, float a) {
			vec3 d = abs(p - c) - a;
			return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
		}
		// -------------------------------------------------------------------------

		struct Dist
		{
			int   index;
			float distance;
		};

		// helper function to find if a new object is closer along a ray than the
		// previous one; return the closer object index
		Dist closer( Dist current, int index, float t )
		{
			if( t <= current.distance )
			{
				current.distance = t;
				current.index    = index;
			}

			return current;
		}

		// -------------------------------------------------------------------------

		// OVERALL SCENE DISTANCE FUNCTION

		// return Dist instance of the object closest to the current
		// position on the ray
		// return Dist instance of the object closest to the current
		// position on the ray
		Dist dScene( vec3 p ) //
		{
			Dist hit = Dist( -1, INFINITY );

			hit = closer( hit, 1, dPlane(p) );
			hit = closer( hit, 2, dSphere(p, vec3(-0.5,0.5,0), 0.5) );
			hit = closer( hit, 3, dSphere(p, vec3(0.5,0.5,0), 0.5) ); // Daelyn: Second sphere
			hit = closer( hit, 4, dSphere(p, vec3(1.5,0.5,0), 0.5) ); // Daelyn: Third sphere
			hit = closer( hit, 5, dSphere(p, vec3(-1.5,0.5,0), 0.5) ); // Daelyn: Fourth sphere
			hit = closer( hit, 6, dSphere(p, vec3(-2.5,0.5,0), 0.5) ); // Daelyn: Fifth sphere
			hit = closer( hit, 7, dCube(p, vec3(2.5,0.5,0), 0.5) ); // Daelyn: Cube
			// more objects here ...

			return hit;
		}


		// use dScene and finite differences to estimate the normal of the object
		// at position x
		vec3 nScene( in vec3 x )
		{
			vec3 n;

			float epsilon = uSettings.epsilon;

			n.x = dScene( x + vec3(epsilon,0,0) ).distance - dScene( x - vec3(epsilon,0,0) ).distance;
			n.y = dScene( x + vec3(0,epsilon,0) ).distance - dScene( x - vec3(0,epsilon,0) ).distance;
			n.z = dScene( x + vec3(0,0,epsilon) ).distance - dScene( x - vec3(0,0,epsilon) ).distance;

			float nl = length(n);

			if( nl > 0.0 )
				n /= nl;

			return n;
		}

		// -------------------------------------------------------------------------

		struct Ray
		{
			vec3 o; // origin
			vec3 d; // direction (normalized)
		};

		// march along a ray using the distance field, until an object is approached
		// very closely (ro: ray origin, rd: ray direction)
		// returns index -1 if no hit is discovered
		Dist raymarch( Ray r )
		{
			float t = 0.0;

			for(int j = 0; j < MAX_MARCHING_STEPS; j++)
			{
				// calculate the current position on the ray
				vec3 pos = r.o + r.d * t;

				// get the distance and index of the object closest to position
				Dist result = dScene(pos);

				// if the distance is under the threshold, return the RayHit
				if( result.distance < uSettings.epsilon )
				{
					result.distance += t;
					return result;
				}

				// add the current distance to the raymarch step length
				t += result.distance;
			}

			return Dist( -1, INFINITY );
		}

		// -------------------------------------------------------------------------

		// helper function to obtain the ray direction of the ray going through
		// the pixel this shader instance is called for
		Ray getRayForCurrentPixel()
		{
			// compute normalized viewport coordinates
			vec2 pixelCoord = -1.0 + 2.0*(gl_FragCoord.xy / uSettings.resolution);

			// set ray direction
			return Ray( uCamera.eye, normalize( uCamera.forward * uCamera.focalLength +
												uCamera.right * pixelCoord.x * uCamera.aspectRatio +
												uCamera.up * pixelCoord.y) );
		}

		// Daelyn: calculating phong lighting
		vec3 calculatePhongLighting(vec3 pos, vec3 norm, vec3 viewDir, Light light, Material mat) {
			vec3 lightDir = normalize(light.position - pos);
			vec3 reflectDir = reflect(-lightDir, norm);
			
			// Ambient
			vec3 ambient = light.ambientIntensity * mat.ambientColor * light.color;
			
			// Diffuse 
			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = diff * light.diffuseIntensity * mat.diffuseColor * light.color;
			
			// Specular
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), mat.shininess);
			vec3 specular = spec * light.specularIntensity * mat.specularColor * light.color;
			
			return ambient + diffuse + specular;
		}
		
		// main raytracing loop, automatically called for each viewport pixel
		void main(void) {
			Ray r = getRayForCurrentPixel();
			vec3 viewDir = normalize(-r.d);
			vec3 finalColor = vec3(0,0,0);
			Dist hit = raymarch(r);
		
			if (hit.index != -1) {
				vec3 pos = r.o + r.d * hit.distance;
				vec3 nrm = nScene(pos);
				
				Material mat;
				if (hit.index == 1) {
					mat = Material(vec3(0.1), vec3(0.8), vec3(1.0), 32.0); // Example material
				}
				// other objects
				
				Light sun = Light(vec3(10, 10, 10), vec3(1, 1, 1), 0.1, 0.9, 0.5); // Example sun light
		
				finalColor = calculatePhongLighting(pos, nrm, viewDir, sun, mat);
			}
		
			gl_FragColor = vec4(finalColor, 1.0);
		}
		
		
	</script>

	<script type="text/javascript">
		// Create Renderer Object
		var renderer = new Renderer(
			document.getElementById('canvas'),	// Canvas element
			600,	// height
			1200,	// width
			document.getElementById('iFocalLength'), // FocalLength input element
			document.getElementById('iEpsilon')      // Epsilon input element
		);
    </script>
  </body>
</html>
